<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HVRX Orbital Platform</title>
  <link rel="icon" href="data:," />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#000000;
      --panel:rgba(10, 14, 28, 0.68);
      --panel2:rgba(10, 14, 28, 0.82);
      --stroke:rgba(120, 160, 255, 0.22);
      --text:#EAF1FF;
      --muted:#9FB3D9;

      --nebulaViolet:#7A5CFF;
      --stellarCyan:#00E6FF;
      --solarGold:#FFCC33;

      --btnGrad: linear-gradient(90deg, rgba(122,92,255,1), rgba(0,230,255,1));
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }

    html, body { margin:0; height:100%; overflow:hidden; background:var(--bg); font-family:Montserrat,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #app { position:fixed; inset:0; }

    #c {
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
      background:#000;
    }

    .panel{
      position:fixed;
      top:18px;
      width:340px;
      background:var(--panel);
      border:1px solid var(--stroke);
      border-radius:14px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color:var(--text);
      overflow:hidden;
      z-index:10;
    }
    .panel.left{ left:18px; }
    .panel.right{ right:18px; width:340px; }

    .panelHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(120,160,255,.14);
      background:linear-gradient(180deg, rgba(16,20,40,.65), rgba(16,20,40,.25));
    }
    .title{
      font-weight:800;
      letter-spacing:1.6px;
      font-size:14px;
      text-transform:uppercase;
      color:rgba(234,241,255,.95);
    }
    .subtitle{
      margin-top:6px;
      font-size:12px;
      color:rgba(159,179,217,.95);
      line-height:1.2;
    }

    .panelBody{ padding:12px 14px 14px; }

    label{
      display:block;
      font-size:11px;
      letter-spacing:.6px;
      color:rgba(159,179,217,.95);
      margin:10px 0 6px;
    }
    input, textarea, select{
      width:100%;
      box-sizing:border-box;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid rgba(120,160,255,.18);
      background:rgba(0,0,0,.35);
      color:var(--text);
      outline:none;
      font-family:inherit;
      font-size:12px;
    }
    input::placeholder, textarea::placeholder{ color:rgba(159,179,217,.65); }
    textarea{ min-height:100px; resize:vertical; }

    .row{ display:flex; gap:10px; }
    .row > div{ flex:1; }

    .btn{
      width:100%;
      margin-top:12px;
      padding:12px 12px;
      border-radius:12px;
      border:0;
      cursor:pointer;
      font-weight:800;
      letter-spacing:1px;
      color:#06101C;
      background:var(--btnGrad);
      box-shadow:0 10px 22px rgba(0,230,255,.12), 0 10px 22px rgba(122,92,255,.10);
      text-transform:uppercase;
      font-size:12px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary{
      background:rgba(0,0,0,.35);
      color:var(--text);
      border:1px solid rgba(0,230,255,.20);
      box-shadow:none;
      text-transform:none;
      font-weight:700;
      letter-spacing:.6px;
    }

    .note{
      margin-top:10px;
      font-size:11px;
      color:rgba(159,179,217,.9);
      line-height:1.3;
    }
    .chip{
      display:inline-block;
      font-size:10px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,204,51,.20);
      color:rgba(255,204,51,.95);
      background:rgba(255,204,51,.08);
      margin-top:8px;
    }

    .satList{
      margin-top:10px;
      border-top:1px solid rgba(120,160,255,.12);
      padding-top:10px;
      max-height:35vh;
      overflow:auto;
    }
    .satItem{
      display:flex; align-items:center; justify-content:space-between;
      padding:9px 10px;
      border-radius:10px;
      border:1px solid rgba(120,160,255,.14);
      background:rgba(0,0,0,.25);
      margin-bottom:8px;
      cursor:pointer;
      user-select:none;
    }
    .satItem:hover{ border-color:rgba(0,230,255,.28); }
    .satName{
      font-size:12px;
      font-weight:700;
      color:rgba(234,241,255,.95);
      max-width:220px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pill{
      font-size:10px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(0,230,255,.22);
      color:rgba(0,230,255,.95);
      background:rgba(0,230,255,.08);
    }

    .infoBox{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(120,160,255,.14);
      background:rgba(0,0,0,.22);
      color:rgba(234,241,255,.92);
      font-size:12px;
      line-height:1.35;
    }
    .infoRow{ display:flex; justify-content:space-between; gap:10px; }
    .infoK{ color:rgba(159,179,217,.92); font-weight:700; }
    .infoV{ color:rgba(234,241,255,.95); font-weight:800; text-align:right; }

    #hud{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:18px;
      background:var(--panel2);
      border:1px solid rgba(120,160,255,.18);
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      box-shadow:var(--shadow);
      font-size:12px;
      display:flex;
      gap:12px;
      align-items:center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index:20;
    }
    #hud .k{ color:rgba(159,179,217,.95); font-weight:700; }
    #hud .v{ color:rgba(234,241,255,.95); font-weight:800; letter-spacing:.2px; }
    #hud .dot{ width:6px; height:6px; border-radius:50%; background:var(--stellarCyan); box-shadow:0 0 10px rgba(0,230,255,.6); }

    .panel.planet{
      top:auto;
      bottom:18px;
      right:18px;
      width:340px;
      z-index:15;
    }

    @media (max-width: 980px){
      .panel.right{ display:none; }
      .panel.left{ width:340px; }
      .panel.planet{ display:none; }
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="c"></canvas>

    <div class="panel left">
      <div class="panelHeader">
        <div class="title">HVRX ORBITAL PLATFORM</div>
        <div class="subtitle">3D Earth + live public satellite positions (TLE). Orbital planner gives weather-aware launch window suggestions.</div>
        <div class="chip">MVP — heavy load mode</div>
      </div>

      <div class="panelBody">
        <label>Recommended launch sites</label>
        <select id="launchPreset">
          <option value="28.3922,-80.6077">Cape Canaveral, USA (28.3922, -80.6077)</option>
          <option value="34.6328,-120.6107">Vandenberg, USA (34.6328, -120.6107)</option>
          <option value="45.9650,63.3050">Baikonur, KZ (45.9650, 63.3050)</option>
          <option value="5.2360,-52.7680">Kourou, FR-GF (5.2360, -52.7680)</option>
          <option value="13.7199,80.2304">Sriharikota, IN (13.7199, 80.2304)</option>
          <option value="31.2510,131.0820">Tanegashima, JP (31.2510, 131.0820)</option>
        </select>

        <div class="row">
          <div>
            <label>Launch site (lat, lon)</label>
            <input id="launchLatLon" value="28.3922,-80.6077" />
          </div>
        </div>

        <div class="row">
          <div>
            <label>Target inclination (deg)</label>
            <input id="targetInc" value="51.6" />
          </div>
          <div>
            <label>Target altitude (km)</label>
            <input id="targetAlt" value="400" />
          </div>
        </div>

        <button id="launchBtn" class="btn">Compute launch window overview</button>

        <label>Launch window overview (UTC)</label>
        <textarea id="launchOut" placeholder="Recommendations will appear here..."></textarea>

        <div class="note">
          Planner uses free weather data + a simple “orbital congestion index” (how many active sats cluster near your target incl/alt).
        </div>

        <button id="loadAllBtn" class="btn">Load all active Earth satellites</button>
        <button id="clearBtn" class="btn secondary">Clear</button>
      </div>
    </div>

    <div class="panel right">
      <div class="panelHeader">
        <div class="title">SATELLITES</div>
        <div class="subtitle">Search and select. Only the selected satellite draws a gold track.</div>
      </div>

      <div class="panelBody">
        <label>Search by name / NORAD</label>
        <input id="search" placeholder="e.g., ISS, STARLINK, 25544..." />
        <div class="satList" id="satList"></div>

        <div class="infoBox">
          <div class="infoRow"><span class="infoK">Selected</span><span class="infoV" id="infoName">—</span></div>
          <div class="infoRow"><span class="infoK">Lat</span><span class="infoV" id="infoLat">—</span></div>
          <div class="infoRow"><span class="infoK">Lon</span><span class="infoV" id="infoLon">—</span></div>
          <div class="infoRow"><span class="infoK">Alt (km)</span><span class="infoV" id="infoAlt">—</span></div>
          <div class="infoRow"><span class="infoK">Speed (km/s)</span><span class="infoV" id="infoSpd">—</span></div>
          <div class="infoRow"><span class="infoK">UTC</span><span class="infoV" id="infoUtc">—</span></div>
        </div>

        <div class="note" id="catalogNote">Catalog: —</div>
      </div>
    </div>

    <div class="panel planet">
      <div class="panelHeader">
        <div class="title">BODY SELECT</div>
        <div class="subtitle">Pick a planet/moon catalog. Earth is wired to public “active” TLEs. Others are framework placeholders.</div>
      </div>
      <div class="panelBody">
        <label>Celestial body</label>
        <select id="bodySelect">
          <option value="earth">Earth (Active satellites)</option>
          <option value="moon">Moon (framework)</option>
          <option value="mars">Mars (framework)</option>
          <option value="jupiter">Jupiter (framework)</option>
        </select>
        <div class="note" id="bodyNote">
          Earth loads from a public TLE catalog. For other bodies, you’ll need a public orbital element feed (mission catalogs differ by agency).
        </div>
      </div>
    </div>

    <div id="hud">
      <span class="dot"></span>
      <span class="k">STATUS</span><span class="v" id="status">READY</span>
      <span class="k">SAT</span><span class="v" id="satCount">0</span>
      <span class="k">SELECTED</span><span class="v" id="selectedName">—</span>
    </div>
  </div>

  <!-- satellite.js stays non-module (UMD global window.satellite) -->
  <script data-cfasync="false" src="https://cdn.jsdelivr.net/npm/satellite.js@5.0.1/dist/satellite.min.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.module.js"
  }
}
</script>

<!-- Three.js + OrbitControls as ES modules -->
<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.148.0/examples/jsm/controls/OrbitControls.js";


    (function () {
      "use strict";

      // ---------- UI helpers ----------
      const el = (id) => document.getElementById(id);

      const statusEl = el("status");
      const satCountEl = el("satCount");
      const selectedNameEl = el("selectedName");
      const satListEl = el("satList");
      const searchEl = el("search");
      const catalogNoteEl = el("catalogNote");
      const bodySelectEl = el("bodySelect");

      const infoName = el("infoName");
      const infoLat  = el("infoLat");
      const infoLon  = el("infoLon");
      const infoAlt  = el("infoAlt");
      const infoSpd  = el("infoSpd");
      const infoUtc  = el("infoUtc");

      const launchOut = el("launchOut");
      const launchLatLon = el("launchLatLon");
      const targetIncEl = el("targetInc");
      const targetAltEl = el("targetAlt");
      const presetEl = el("launchPreset");

      function setStatus(s){ if (statusEl) statusEl.textContent = s; }
      function setSelectedName(s){
        if (selectedNameEl) selectedNameEl.textContent = s;
        if (infoName) infoName.textContent = s;
      }
      function updateSatCount(n){ if (satCountEl) satCountEl.textContent = String(n); }

      // ---------- Hard dependency checks ----------
      if (!THREE) {
        setStatus("THREE FAILED");
        console.error("THREE import failed.");
        alert("THREE module failed to import. Check Network tab for three.module.js.");
        return;
      }
      if (!OrbitControls) {
        setStatus("CONTROLS FAILED");
        console.error("OrbitControls import failed.");
        alert("OrbitControls module failed to import. Check Network tab for OrbitControls.js.");
        return;
      }

      // satellite is optional (globe should still render)
      const satellite = window.satellite || null;
      if (!satellite) console.warn("satellite.js not loaded (sat features will be disabled).");

      // ---------- Wire presets ----------
      if (presetEl) {
        presetEl.addEventListener("change", () => { launchLatLon.value = presetEl.value; });
      }

      // ---------- Three.js setup ----------
      const canvas = el("c");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      renderer.setSize(window.innerWidth, window.innerHeight);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
      camera.position.set(0, 0, 260);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.target.set(0,0,0);
      controls.minDistance = 140;
      controls.maxDistance = 800;

      scene.add(new THREE.AmbientLight(0xffffff, 0.85));
      const sun = new THREE.DirectionalLight(0xffffff, 0.85);
      sun.position.set(1, 0.4, 1);
      scene.add(sun);

      // Stars
      const starGeo = new THREE.BufferGeometry();
      const starCount = 2000;
      const starPos = new Float32Array(starCount * 3);
      for (let i=0;i<starCount;i++){
        const r = 2200 + Math.random()*1200;
        const th = Math.random()*Math.PI*2;
        const ph = Math.acos(2*Math.random()-1);
        starPos[i*3+0] = r * Math.sin(ph)*Math.cos(th);
        starPos[i*3+1] = r * Math.cos(ph);
        starPos[i*3+2] = r * Math.sin(ph)*Math.sin(th);
      }
      starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
      scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 2, sizeAttenuation: true })));

      // Earth
      const R = 100;
      const EARTH_KM = 6371;
      const SCALE = R / EARTH_KM;

      const earthGroup = new THREE.Group();
      scene.add(earthGroup);

      const earthGeom = new THREE.SphereGeometry(R, 96, 96);

      function buildAtmosphere(){
        const atmoGeom = new THREE.SphereGeometry(R * 1.02, 96, 96);
        const atmoMat  = new THREE.MeshBasicMaterial({ color: 0x00E6FF, transparent:true, opacity:0.05 });
        earthGroup.add(new THREE.Mesh(atmoGeom, atmoMat));
      }

      let earthBuilt = false;
      function buildFallbackEarth(){
        if (earthBuilt) return;
        earthBuilt = true;
        const mat = new THREE.MeshStandardMaterial({
          color: 0x0B1530, roughness:0.85, metalness:0.10,
          emissive: new THREE.Color(0x08122A), emissiveIntensity:1.25
        });
        earthGroup.add(new THREE.Mesh(earthGeom, mat));
        buildAtmosphere();
      }

      const texLoader = new THREE.TextureLoader();
      texLoader.crossOrigin = ("anonymous");

      const urls = {
  day:  "https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg",
  bump: "https://threejs.org/examples/textures/planets/earth_normal_2048.jpg",
  spec: "https://threejs.org/examples/textures/planets/earth_specular_2048.jpg"
      };

      const tex = { day:null, bump:null, spec:null };
      function tryBuildEarth(){
        if (earthBuilt) return;
        if (!tex.day || !tex.bump || !tex.spec) return;
        earthBuilt = true;

       const mat = new THREE.MeshPhongMaterial({
  map: tex.day,
  normalMap: tex.bump,         
  specularMap: tex.spec,
  specular: new THREE.Color(0x222222),
  shininess: 12
});
        earthGroup.add(new THREE.Mesh(earthGeom, mat));
        buildAtmosphere();
      }

      texLoader.load(urls.day,  (t)=>{ tex.day=t;  tryBuildEarth(); }, undefined, (e)=>{ console.error("DAY tex failed", urls.day, e);  buildFallbackEarth(); });
      texLoader.load(urls.bump, (t)=>{ tex.bump=t; tryBuildEarth(); }, undefined, (e)=>{ console.error("BUMP tex failed", urls.bump, e); buildFallbackEarth(); });
      texLoader.load(urls.spec, (t)=>{ tex.spec=t; tryBuildEarth(); }, undefined, (e)=>{ console.error("SPEC tex failed", urls.spec, e); buildFallbackEarth(); });
      setTimeout(() => { if (!earthBuilt) buildFallbackEarth(); }, 6000);

      // ---------- Satellites ----------
      let sats = [];
      let selected = null;
      let satMesh = null;
      let trackLine = null;
      let lastPosUpdateMs = 0;

      const SAT_POINT_RADIUS = 0.6;
      const SAT_COLOR_DEFAULT = new THREE.Color(0x00E6FF);
      const SAT_COLOR_SELECTED = new THREE.Color(0xFFCC33);

      function ecefKmToScene(v){
        return new THREE.Vector3(v.x * SCALE, v.z * SCALE, v.y * SCALE);
      }

      function parseTleText(text){
        const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
        const out = [];
        for (let i=0;i<lines.length-2;i++){
          const name = lines[i];
          const l1 = lines[i+1];
          const l2 = lines[i+2];
          if (l1.startsWith("1 ") && l2.startsWith("2 ")){
            const norad = l1.slice(2,7).trim();
            out.push({ name, norad, l1, l2 });
            i += 2;
          }
        }
        return out;
      }

      function escapeHtml(s){
        return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
      }

      function clearTrack(){
        if (trackLine){
          scene.remove(trackLine);
          trackLine.geometry.dispose();
          trackLine.material.dispose();
          trackLine = null;
        }
      }

      function buildSatInstancedMesh(n){
        if (satMesh){
          scene.remove(satMesh);
          satMesh.geometry.dispose();
          satMesh.material.dispose();
        }
        const geom = new THREE.SphereGeometry(SAT_POINT_RADIUS, 10, 10);
        const mat  = new THREE.MeshBasicMaterial({ color: 0xffffff });
        satMesh = new THREE.InstancedMesh(geom, mat, n);
        satMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        satMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(n*3), 3);
        satMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);

        const m = new THREE.Matrix4();
        for (let i=0;i<n;i++){
          m.makeTranslation(99999,99999,99999);
          satMesh.setMatrixAt(i, m);
          satMesh.setColorAt(i, SAT_COLOR_DEFAULT);
          sats[i].meshIndex = i;
        }
        satMesh.instanceMatrix.needsUpdate = true;
        satMesh.instanceColor.needsUpdate = true;

        scene.add(satMesh);
      }

      function renderSatList(){
        const q = (searchEl.value || "").trim().toLowerCase();
        const matches = [];
        for (const s of sats){
          if (!q || s.name.toLowerCase().includes(q) || s.norad.includes(q)) matches.push(s);
          if (matches.length >= 80) break;
        }
        satListEl.innerHTML = "";
        for (const s of matches){
          const row = document.createElement("div");
          row.className = "satItem";
          row.innerHTML = `<div class="satName">${escapeHtml(s.name)} <span style="color:rgba(159,179,217,.8);font-weight:700">(${s.norad})</span></div><div class="pill">TRACK</div>`;
          row.addEventListener("click", () => selectSatByNorad(s.norad));
          satListEl.appendChild(row);
        }
      }

      function setAllColorsDefault(){
        if (!satMesh) return;
        for (let i=0;i<sats.length;i++) satMesh.setColorAt(i, SAT_COLOR_DEFAULT);
        satMesh.instanceColor.needsUpdate = true;
      }

      function selectSatByNorad(norad){
        const s = sats.find(x => x.norad === norad) || null;
        selected = s;
        setSelectedName(s ? s.name : "—");

        if (satMesh){
          setAllColorsDefault();
          if (s){
            satMesh.setColorAt(s.meshIndex, SAT_COLOR_SELECTED);
            satMesh.instanceColor.needsUpdate = true;
          }
        }

        clearTrack();
        if (s && satellite) buildSelectedTrack(s, 90, 2);
      }

      function buildSelectedTrack(sat, minutesAhead=90, stepMin=2){
        const pts = [];
        const now = new Date();
        for (let m=0; m<=minutesAhead; m+=stepMin){
          const t = new Date(now.getTime() + m*60*1000);
          const pv = satellite.propagate(sat.satrec, t);
          if (!pv.position) continue;
          const gmst = satellite.gstime(t);
          const ecef = satellite.eciToEcf(pv.position, gmst);
          pts.push(ecefKmToScene(ecef));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({ color: 0xFFCC33, transparent:true, opacity:0.85 });
        trackLine = new THREE.Line(geo, mat);
        trackLine.userData.last = performance.now();
        scene.add(trackLine);
      }

      function updateSatPositions(){
        if (!satellite || !satMesh || !sats.length) return;
        const t = new Date();
        const gmst = satellite.gstime(t);

        const mat4 = new THREE.Matrix4();
        for (let i=0;i<sats.length;i++){
          const s = sats[i];
          const pv = satellite.propagate(s.satrec, t);
          if (!pv.position){
            mat4.makeTranslation(99999,99999,99999);
            satMesh.setMatrixAt(i, mat4);
            continue;
          }
          const ecef = satellite.eciToEcf(pv.position, gmst);
          const p = ecefKmToScene(ecef);
          mat4.makeTranslation(p.x, p.y, p.z);
          satMesh.setMatrixAt(i, mat4);
        }
        satMesh.instanceMatrix.needsUpdate = true;

        if (selected){
          const pv = satellite.propagate(selected.satrec, t);
          if (pv.position && pv.velocity){
            const geo = satellite.eciToGeodetic(pv.position, gmst);
            infoLat.textContent = satellite.degreesLat(geo.latitude).toFixed(2);
            infoLon.textContent = satellite.degreesLong(geo.longitude).toFixed(2);
            infoAlt.textContent = geo.height.toFixed(1);
            const v = pv.velocity;
            const spd = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
            infoSpd.textContent = spd.toFixed(3);
            infoUtc.textContent = t.toISOString().replace("T"," ").slice(0,19) + "Z";
          }
        } else {
          infoLat.textContent = infoLon.textContent = infoAlt.textContent = infoSpd.textContent = infoUtc.textContent = "—";
        }
      }

      async function loadEarthActive(){
        if (!satellite){
          alert("satellite.js is not loaded, so satellites are disabled. The globe should still render. Check the Network tab for satellite.min.js.");
          return;
        }

        setStatus("LOADING CATALOG…");
        setSelectedName("—");
        selected = null;
        clearTrack();

        const url = "https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=tle";
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error("Catalog HTTP " + res.status);

        const text = await res.text();
        const items = parseTleText(text);

        sats = items.map(it => {
          const sr = satellite.twoline2satrec(it.l1, it.l2);
          const inclDeg = sr.inclo * 180 / Math.PI;
          return { name: it.name, norad: it.norad, satrec: sr, inclDeg, meshIndex: -1 };
        });

        buildSatInstancedMesh(sats.length);
        updateSatCount(sats.length);
        catalogNoteEl.textContent = "Catalog: Earth / active (" + sats.length + " objects)";
        setStatus("READY");
        renderSatList();
      }

      function clearAll(){
        setStatus("READY");
        sats = [];
        selected = null;
        updateSatCount(0);
        setSelectedName("—");
        catalogNoteEl.textContent = "Catalog: —";
        satListEl.innerHTML = "";
        clearTrack();
        if (satMesh){
          scene.remove(satMesh);
          satMesh.geometry.dispose();
          satMesh.material.dispose();
          satMesh = null;
        }
      }

      function onBodyChange(){
        const body = bodySelectEl.value;
        if (body === "earth"){
          catalogNoteEl.textContent = "Catalog: Earth / active (ready)";
          return;
        }
        clearAll();
        setStatus("BODY NOT WIRED");
        catalogNoteEl.textContent = "Catalog: " + body + " (not wired)";
        launchOut.value = "Selected body: " + body + "\n\nEarth works today because public TLE catalogs exist.\n";
      }

      function computeLaunchOverview(){
        launchOut.value =
          "This is the overview placeholder.\n\n" +
          "Next step: we can add weather + congestion scoring back once the base loads reliably.\n";
      }

      // Wire UI
      el("loadAllBtn").addEventListener("click", () => loadEarthActive().catch(e => { setStatus("ERROR"); alert(String(e)); }));
      el("clearBtn").addEventListener("click", clearAll);
      el("launchBtn").addEventListener("click", computeLaunchOverview);
      searchEl.addEventListener("input", renderSatList);
      bodySelectEl.addEventListener("change", onBodyChange);

      onBodyChange();

      // Animate loop
      function animate(){
        const nowMs = performance.now();
        if (nowMs - lastPosUpdateMs > 1000){
          updateSatPositions();
          lastPosUpdateMs = nowMs;

          if (satellite && selected && trackLine && (nowMs - (trackLine.userData.last || 0) > 10000)){
            clearTrack();
            buildSelectedTrack(selected, 90, 2);
          }
        }
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // If we got here, the globe WILL render.
      setStatus("READY");
    })();
  </script>
</body>
</html>





