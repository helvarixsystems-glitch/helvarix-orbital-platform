<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HVRX Orbital Platform</title>
  <link rel="icon" href="data:," />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#000000;
      --panel:rgba(10, 14, 28, 0.68);
      --panel2:rgba(10, 14, 28, 0.82);
      --stroke:rgba(120, 160, 255, 0.22);
      --text:#EAF1FF;
      --muted:#9FB3D9;

      --nebulaViolet:#7A5CFF;
      --stellarCyan:#00E6FF;
      --solarGold:#FFCC33;

      --btnGrad: linear-gradient(90deg, rgba(122,92,255,1), rgba(0,230,255,1));
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }

    html, body { margin:0; height:100%; overflow:hidden; background:var(--bg); font-family:Montserrat,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #app { position:fixed; inset:0; }

    #c {
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
      background:#000;
    }

    .panel{
      position:fixed;
      top:18px;
      width:340px;
      background:var(--panel);
      border:1px solid var(--stroke);
      border-radius:14px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color:var(--text);
      overflow:hidden;
      z-index:10;
    }
    .panel.left{ left:18px; }
    .panel.right{
      right:18px;
      width:340px;
      bottom: 240px;              /* adjust this number if needed */
      height: auto;               /* let top+bottom define height */

      display:flex;
      flex-direction:column;
    }
    .panel.right .panelBody{
      display:flex;
      flex-direction:column;
      min-height:0; /* ✅ important so overflow works inside flex */
    }
    .satList{
      flex:1;        /* ✅ list takes remaining space */
      min-height:0;  /* ✅ allows it to shrink */
      overflow:auto;
    }

    .panelHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(120,160,255,.14);
      background:linear-gradient(180deg, rgba(16,20,40,.65), rgba(16,20,40,.25));
    }
    .title{
      font-weight:800;
      letter-spacing:1.6px;
      font-size:14px;
      text-transform:uppercase;
      color:rgba(234,241,255,.95);
    }
    .subtitle{
      margin-top:6px;
      font-size:12px;
      color:rgba(159,179,217,.95);
      line-height:1.2;
    }

    .panelBody{ padding:12px 14px 14px; }
    .panel.right .panelBody{
      padding:12px 14px 14px;
      display:flex;
      flex-direction:column;
      min-height:0; /* ✅ critical so overflow works inside flex */
    }
    label{
      display:block;
      font-size:11px;
      letter-spacing:.6px;
      color:rgba(159,179,217,.95);
      margin:10px 0 6px;
    }
    input, textarea, select{
      width:100%;
      box-sizing:border-box;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid rgba(120,160,255,.18);
      background:rgba(0,0,0,.35);
      color:var(--text);
      outline:none;
      font-family:inherit;
      font-size:12px;
    }
    input::placeholder, textarea::placeholder{ color:rgba(159,179,217,.65); }
    textarea{ min-height:100px; resize:vertical; }

    .row{ display:flex; gap:10px; }
    .row > div{ flex:1; }

    .btn{
      width:100%;
      margin-top:12px;
      padding:12px 12px;
      border-radius:12px;
      border:0;
      cursor:pointer;
      font-weight:800;
      letter-spacing:1px;
      color:#06101C;
      background:var(--btnGrad);
      box-shadow:0 10px 22px rgba(0,230,255,.12), 0 10px 22px rgba(122,92,255,.10);
      text-transform:uppercase;
      font-size:12px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary{
      background:rgba(0,0,0,.35);
      color:var(--text);
      border:1px solid rgba(0,230,255,.20);
      box-shadow:none;
      text-transform:none;
      font-weight:700;
      letter-spacing:.6px;
    }

    .note{
      margin-top:10px;
      font-size:11px;
      color:rgba(159,179,217,.9);
      line-height:1.3;
    }
    .chip{
      display:inline-block;
      font-size:10px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,204,51,.20);
      color:rgba(255,204,51,.95);
      background:rgba(255,204,51,.08);
      margin-top:8px;
    }

    .satList{
      margin-top:10px;
      border-top:1px solid rgba(120,160,255,.12);
      padding-top:10px;
      flex:1;
      min-height:0;
      overflow:auto;
    }
    .satItem{
      display:flex; align-items:center; justify-content:space-between;
      padding:9px 10px;
      border-radius:10px;
      border:1px solid rgba(120,160,255,.14);
      background:rgba(0,0,0,.25);
      margin-bottom:8px;
      cursor:pointer;
      user-select:none;
    }
    .satItem:hover{ border-color:rgba(0,230,255,.28); }
    .satName{
      font-size:12px;
      font-weight:700;
      color:rgba(234,241,255,.95);
      max-width:220px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pill{
      font-size:10px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(0,230,255,.22);
      color:rgba(0,230,255,.95);
      background:rgba(0,230,255,.08);
    }

    .infoBox{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(120,160,255,.14);
      background:rgba(0,0,0,.22);
      color:rgba(234,241,255,.92);
      font-size:12px;
      line-height:1.35;
    }
    .infoRow{ display:flex; justify-content:space-between; gap:10px; }
    .infoK{ color:rgba(159,179,217,.92); font-weight:700; }
    .infoV{ color:rgba(234,241,255,.95); font-weight:800; text-align:right; }

    #hud{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:18px;
      background:var(--panel2);
      border:1px solid rgba(120,160,255,.18);
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      box-shadow:var(--shadow);
      font-size:12px;
      display:flex;
      gap:12px;
      align-items:center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index:20;
    }
    #hud .k{ color:rgba(159,179,217,.95); font-weight:700; }
    #hud .v{ color:rgba(234,241,255,.95); font-weight:800; letter-spacing:.2px; }
    #hud .dot{ width:6px; height:6px; border-radius:50%; background:var(--stellarCyan); box-shadow:0 0 10px rgba(0,230,255,.6); }

    .panel.planet{
      top:auto;
      bottom:18px;
      right:18px;
      width:340px;
      z-index:15;
    }

    @media (max-width: 980px){
      .panel.right{ display:none; }
      .panel.left{ width:340px; }
      .panel.planet{ display:none; }
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="c"></canvas>

    <div class="panel left">
      <div class="panelHeader">
        <div class="title">HVRX ORBITAL PLATFORM</div>
        <div class="subtitle">3D Earth + live public satellite positions (TLE). Orbital planner gives weather-aware launch window suggestions.</div>
        <div class="chip">BETA</div>
      </div>

      <div class="panelBody">
        <label>Recommended launch sites</label>
        <select id="launchPreset">
          <option value="28.3922,-80.6077">Cape Canaveral, USA (28.3922, -80.6077)</option>
          <option value="34.6328,-120.6107">Vandenberg, USA (34.6328, -120.6107)</option>
          <option value="45.9650,63.3050">Baikonur, KZ (45.9650, 63.3050)</option>
          <option value="5.2360,-52.7680">Kourou, FR-GF (5.2360, -52.7680)</option>
          <option value="13.7199,80.2304">Sriharikota, IN (13.7199, 80.2304)</option>
          <option value="31.2510,131.0820">Tanegashima, JP (31.2510, 131.0820)</option>
        </select>

        <div class="row">
          <div>
            <label>Launch site (lat, lon)</label>
            <input id="launchLatLon" value="28.3922,-80.6077" />
          </div>
        </div>

        <div class="row">
          <div>
            <label>Target inclination (deg)</label>
            <input id="targetInc" value="51.6" />
          </div>
          <div>
            <label>Target altitude (km)</label>
            <input id="targetAlt" value="400" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Target RAAN (deg, optional)</label>
            <input id="targetRAAN"
                   placeholder="0–360 (leave blank for lighting schedule only)"
                   autocomplete="off" />
          </div>
        </div>
        <button id="launchBtn" class="btn">Compute launch window overview</button>

        <label>Launch window overview (UTC)</label>
        <textarea id="launchOut" placeholder="Recommendations will appear here..."></textarea>
        <button id="downloadLaunchBtn" class="btn secondary">Download launch overview (.txt)</button>
        <div class="note">
          Planner uses free weather data + a simple “orbital congestion index” (how many active sats cluster near your target incl/alt).
        </div>

        <button id="clearBtn" class="btn secondary">Clear</button>
      </div>
    </div>

    <div class="panel right">
      <div class="panelHeader">
        <div class="title">SATELLITES</div>
        <div class="subtitle">Search and select. Only the selected satellite draws a gold track.</div>
      </div>

      <div class="panelBody">
        <label>Search by name / NORAD</label>
        <input id="search" placeholder="e.g., ISS, STARLINK, 25544..." />
        <div class="satList" id="satList"></div>

        <div class="infoBox">
          <div class="infoRow"><span class="infoK">Selected</span><span class="infoV" id="infoName">—</span></div>
          <div class="infoRow"><span class="infoK">Lat</span><span class="infoV" id="infoLat">—</span></div>
          <div class="infoRow"><span class="infoK">Lon</span><span class="infoV" id="infoLon">—</span></div>
          <div class="infoRow"><span class="infoK">Alt (km)</span><span class="infoV" id="infoAlt">—</span></div>
          <div class="infoRow"><span class="infoK">Speed (km/s)</span><span class="infoV" id="infoSpd">—</span></div>
          <div class="infoRow"><span class="infoK">UTC</span><span class="infoV" id="infoUtc">—</span></div>
        </div>

        <div class="note" id="catalogNote">Catalog: —</div>
      </div>
    </div>

    <div class="panel planet">
      <div class="panelHeader">
        <div class="title">BODY SELECT</div>
        <div class="subtitle">Pick a planet/moon catalog. Earth is wired to public “active” TLEs. Others use Horizons spacecraft ephemerides.</div>
      </div>
      <div class="panelBody">
        <label>Celestial body</label>
        <select id="bodySelect">
          <option value="earth">Earth (Active satellites)</option>
          <option value="moon">Moon (Horizons)</option>
          <option value="mars">Mars (Horizons)</option>
          <option value="jupiter">Jupiter (Horizons)</option>
        </select>
        <div class="note" id="bodyNote">
          Earth loads from a public TLE catalog. Moon/Mars/Jupiter load from Horizons (spacecraft ephemeris per-object).
        </div>
      </div>
    </div>

    <div id="hud">
      <span class="dot"></span>
      <span class="k">STATUS</span><span class="v" id="status">READY</span>
      <span class="k">SAT</span><span class="v" id="satCount">0</span>
      <span class="k">SELECTED</span><span class="v" id="selectedName">—</span>
    </div>
  </div>

<script src="./assets/vendor/satellite.min.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.module.js"
  }
}
</script>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.148.0/examples/jsm/controls/OrbitControls.js";
  const satellite = window.satellite || null;
  console.log("satellite.js loaded", !!satellite);

  (function () {
    "use strict";

    // ---------- UI helpers ----------
    const el = (id) => document.getElementById(id);

    const statusEl = el("status");
    const satCountEl = el("satCount");
    const selectedNameEl = el("selectedName");
    const satListEl = el("satList");
    const searchEl = el("search");
    const catalogNoteEl = el("catalogNote");
    const bodySelectEl = el("bodySelect");

    const infoName = el("infoName");
    const infoLat  = el("infoLat");
    const infoLon  = el("infoLon");
    const infoAlt  = el("infoAlt");
    const infoSpd  = el("infoSpd");
    const infoUtc  = el("infoUtc");

    const launchOut = el("launchOut");
    const launchLatLon = el("launchLatLon");
    const targetIncEl = el("targetInc");
    const targetAltEl = el("targetAlt");
    const presetEl = el("launchPreset");
    const targetRAANEl = el("targetRAAN");

    function setStatus(s){ if (statusEl) statusEl.textContent = s; }
    function setSelectedName(s){
      if (selectedNameEl) selectedNameEl.textContent = s;
      if (infoName) infoName.textContent = s;
    }
    function updateSatCount(n){ if (satCountEl) satCountEl.textContent = String(n); }

    function downloadText(filename, text){
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // ---------- Hard dependency checks ----------
    if (!THREE) {
      setStatus("THREE FAILED");
      console.error("THREE import failed.");
      alert("THREE module failed to import. Check Network tab for three.module.js.");
      return;
    }
    if (!OrbitControls) {
      setStatus("CONTROLS FAILED");
      console.error("OrbitControls import failed.");
      alert("OrbitControls module failed to import. Check Network tab for OrbitControls.js.");
      return;
    }

    // ---------- Wire presets ----------
    if (presetEl) {
      presetEl.addEventListener("change", () => { launchLatLon.value = presetEl.value; });
    }

    // ---------- Three.js setup ----------
    const canvas = el("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 260);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.target.set(0,0,0);
    controls.minDistance = 140;
    controls.maxDistance = 800;

    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const sun = new THREE.DirectionalLight(0xffffff, 0.85);
    sun.position.set(1, 0.4, 1);
    scene.add(sun);

    // Stars
    const starGeo = new THREE.BufferGeometry();
    const starCount = 2000;
    const starPos = new Float32Array(starCount * 3);
    for (let i=0;i<starCount;i++){
      const r = 2200 + Math.random()*1200;
      const th = Math.random()*Math.PI*2;
      const ph = Math.acos(2*Math.random()-1);
      starPos[i*3+0] = r * Math.sin(ph)*Math.cos(th);
      starPos[i*3+1] = r * Math.cos(ph);
      starPos[i*3+2] = r * Math.sin(ph)*Math.sin(th);
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 2, sizeAttenuation: true })));

    // ---------- Earth / Planet Mesh ----------
    const R = 100;
    const EARTH_KM = 6371;
    const SCALE = R / EARTH_KM; // Earth scale (kept for TLE/ECEF path)

    // body radii + current scale for Horizons bodies
    const BODY_RADIUS_KM = {
      earth: 6371,
      moon: 1737.4,
      mars: 3389.5,
      jupiter: 69911
    };
    let currentBody = "earth";
    let currentScale = R / (BODY_RADIUS_KM[currentBody] || EARTH_KM);

    // Horizons center codes (SSB@BODY)
    const BODY_CENTER = {
      moon: "500@301",
      mars: "500@499",
      jupiter: "500@599"
    };

    // “Exhaustive” practical catalogs (best-effort via name lookup).
    // If you want true reliability, swap to { spkid: "..." } once you confirm IDs.
    const BODY_CRAFT = {
      moon: [
        { query: "LRO", name: "LRO" },
        { query: "CAPSTONE", name: "CAPSTONE" },
        { query: "KPLO", name: "KPLO (DANURI)" },
        { query: "DANURI", name: "DANURI (KPLO)" },
        { query: "Chandrayaan-2", name: "Chandrayaan-2 Orbiter" },
        { query: "SMART-1", name: "SMART-1 (historic)" },
        { query: "KAGUYA", name: "Kaguya / SELENE (historic)" },
        { query: "LADEE", name: "LADEE (historic)" },
        { query: "GRAIL-A", name: "GRAIL-A (historic)" },
        { query: "GRAIL-B", name: "GRAIL-B (historic)" }
      ],
      mars: [
        // Current/Recent orbiters
        { query: "MRO", name: "Mars Reconnaissance Orbiter (MRO)" },
        { query: "MAVEN", name: "MAVEN" },
        { query: "Mars Odyssey", name: "Mars Odyssey" },
        { query: "Mars Express", name: "Mars Express" },
        { query: "EXOMARS TRACE GAS ORBITER", name: "ExoMars TGO" },
        { query: "Trace Gas Orbiter", name: "Trace Gas Orbiter (TGO)" },
        { query: "Tianwen-1", name: "Tianwen-1 Orbiter" },
        { query: "HOPE", name: "Hope / EMM (UAE)" },
        { query: "EMM", name: "EMM / Hope (UAE)" },
        // Historic orbiters (may still resolve in Horizons)
        { query: "MARS GLOBAL SURVEYOR", name: "Mars Global Surveyor (historic)" },
        { query: "MARS CLIMATE ORBITER", name: "Mars Climate Orbiter (historic)" },
        { query: "MARS POLAR LANDER", name: "Mars Polar Lander (historic)" },
        { query: "PHOBOS 2", name: "Phobos 2 (historic)" },
        { query: "PHOBOS 1", name: "Phobos 1 (historic)" },
        { query: "MARS ORBITER MISSION", name: "Mars Orbiter Mission / MOM (historic)" },
        { query: "MANGALYAAN", name: "Mangalyaan / MOM (historic)" }
      ],
      jupiter: [
        // True Jupiter orbiter today
        { query: "JUNO", name: "Juno" },
        // Historic Jupiter orbiter (worked at Jupiter)
        { query: "GALILEO ORBITER", name: "Galileo Orbiter (historic)" },
        // Not orbiters, but sometimes useful to display if Horizons resolves them
        { query: "VOYAGER 1", name: "Voyager 1 (flyby)" },
        { query: "VOYAGER 2", name: "Voyager 2 (flyby)" },
        { query: "PIONEER 10", name: "Pioneer 10 (flyby)" },
        { query: "PIONEER 11", name: "Pioneer 11 (flyby)" },
        { query: "ULYSSES", name: "Ulysses (flyby)" },
        { query: "CASSINI", name: "Cassini (flyby)" },
        { query: "NEW HORIZONS", name: "New Horizons (flyby)" }
      ]
    };

    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    const earthGeom = new THREE.SphereGeometry(R, 96, 96);

    // One shared planet mesh for all bodies
    let planetMesh = new THREE.Mesh(
      earthGeom,
      new THREE.MeshStandardMaterial({
        color: 0x223355,
        roughness: 1.0
      })
    );

    earthGroup.add(planetMesh);

    // Atmosphere
    function buildAtmosphere(){
      const atmoGeom = new THREE.SphereGeometry(R * 1.02, 96, 96);
      const atmoMat  = new THREE.MeshBasicMaterial({
        color: 0x00E6FF,
        transparent: true,
        opacity: 0.05
      });
      earthGroup.add(new THREE.Mesh(atmoGeom, atmoMat));
    }
    buildAtmosphere();

    // Fallback material if textures fail
    function buildFallbackEarth(){
      planetMesh.material = new THREE.MeshStandardMaterial({
        color: 0x0B1530,
        roughness: 0.85,
        metalness: 0.10,
        emissive: new THREE.Color(0x08122A),
        emissiveIntensity: 1.25
      });
      planetMesh.material.needsUpdate = true;
    }

    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin("anonymous");

    const BODY_URLS = {
      earth: {
        map:  "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r148/examples/textures/planets/earth_atmos_2048.jpg",
        normal: "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r148/examples/textures/planets/earth_normal_2048.jpg",
        spec: "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r148/examples/textures/planets/earth_specular_2048.jpg"
      },
      moon: {
        map: "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r148/examples/textures/planets/moon_1024.jpg"
      },
      mars: {
        map: "https://upload.wikimedia.org/wikipedia/commons/4/46/Solarsystemscope_texture_2k_mars.jpg"
      },
      jupiter: {
        map: "https://upload.wikimedia.org/wikipedia/commons/5/5e/Solarsystemscope_texture_8k_jupiter.jpg"
      }
    };

    let earthBuilt = false;
    setTimeout(() => { if (!earthBuilt) buildFallbackEarth(); }, 6000);

    function switchBodyMaterial(bodyKey){
      const cfg = BODY_URLS[bodyKey];
      if (!cfg || !planetMesh) return;

      setStatus("LOADING BODY…");

      texLoader.load(
        cfg.map,
        (map) => {
          map.colorSpace = THREE.SRGBColorSpace;

          if (bodyKey === "earth" && cfg.normal && cfg.spec){
            texLoader.load(
              cfg.normal,
              (normal) => {
                texLoader.load(
                  cfg.spec,
                  (spec) => {
                    planetMesh.material = new THREE.MeshPhongMaterial({
                      map,
                      normalMap: normal,
                      specularMap: spec,
                      specular: new THREE.Color(0x222222),
                      shininess: 12
                    });
                    planetMesh.material.needsUpdate = true;
                    earthBuilt = true;
                    setStatus("READY");
                  },
                  undefined,
                  () => { buildFallbackEarth(); setStatus("READY"); }
                );
              },
              undefined,
              () => { buildFallbackEarth(); setStatus("READY"); }
            );
          } else {
            planetMesh.material = new THREE.MeshStandardMaterial({
              map,
              roughness: bodyKey === "jupiter" ? 0.95 : 1.0,
              metalness: 0
            });
            planetMesh.material.needsUpdate = true;
            earthBuilt = true;
            setStatus("READY");
          }
        },
        undefined,
        (err) => {
          console.error("Texture load failed:", bodyKey, err);
          buildFallbackEarth();
          setStatus("READY");
        }
      );
    }

    // ---------- Satellites ----------
    let sats = [];
    let selected = null;
    let earthLoadPromise = null;
    let satMesh = null;
    let trackLine = null;
    let lastPosUpdateMs = 0;

    let horizonsLoadPromise = null;

    const SAT_POINT_RADIUS = 0.6;
    const SAT_COLOR_DEFAULT = new THREE.Color(0x00E6FF);
    const SAT_COLOR_SELECTED = new THREE.Color(0xFFCC33);

    function ecefKmToScene(v){
      return new THREE.Vector3(
        v.x * SCALE,
        v.z * SCALE,
        -v.y * SCALE
      );
    }

    // ---------- Horizons helpers ----------
    function nowIsoUTC(){ return new Date().toISOString().slice(0,19); }
    function addHoursIsoUTC(h){ return new Date(Date.now() + h*3600*1000).toISOString().slice(0,19); }
    function toJulianForHorizons(date){ return date.getTime()/86400000 + 2440587.5; }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function parseHorizonsCsvVectors(text){
      const start = text.indexOf("$$SOE");
      const end   = text.indexOf("$$EOE");
      if (start === -1 || end === -1 || end <= start) return [];

      const block = text.slice(start + 5, end).trim();
      const lines = block.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

      const out = [];
      for (const line of lines){
        const parts = line.split(",").map(s => s.trim());
        if (parts.length < 7) continue;

        const jd = Number(parts[0]);
        const x  = Number(parts[1]);
        const y  = Number(parts[2]);
        const z  = Number(parts[3]);
        const vx = Number(parts[4]);
        const vy = Number(parts[5]);
        const vz = Number(parts[6]);

        if (![jd,x,y,z,vx,vy,vz].every(n => Number.isFinite(n))) continue;
        out.push({ jd, x_km:x, y_km:y, z_km:z, vx_kms:vx, vy_kms:vy, vz_kms:vz });
      }
      return out;
    }

    function sampleVectorsAt(rows, jdNow){
      if (!rows || rows.length < 2) return null;

      let i = 0;
      while (i < rows.length-2 && rows[i+1].jd < jdNow) i++;

      const a = rows[i];
      const b = rows[i+1];
      const dt = (b.jd - a.jd);
      if (!(dt > 0)) return null;

      const t = (jdNow - a.jd) / dt;
      return {
        x_km: lerp(a.x_km, b.x_km, t),
        y_km: lerp(a.y_km, b.y_km, t),
        z_km: lerp(a.z_km, b.z_km, t),
        vx_kms: lerp(a.vx_kms, b.vx_kms, t),
        vy_kms: lerp(a.vy_kms, b.vy_kms, t),
        vz_kms: lerp(a.vz_kms, b.vz_kms, t),
      };
    }

    async function horizonsLookupBest(name){
      const res = await fetch(`/api/lookup?s=${encodeURIComponent(name)}`);
      if (!res.ok) throw new Error("Lookup HTTP " + res.status);
      const data = await res.json();
      const results = data?.result || [];
      if (!results.length) return null;

      const withSpk = results.find(r => r && r.spkid) || results[0];
      return withSpk?.spkid ? withSpk : null;
    }

    async function horizonsVectorsRows(command, center, startIso, stopIso, stepMin){
      const url =
        `/api/vectors?command=${encodeURIComponent(command)}&center=${encodeURIComponent(center)}&start=${encodeURIComponent(startIso)}&stop=${encodeURIComponent(stopIso)}&stepMin=${encodeURIComponent(String(stepMin))}`;

      const res = await fetch(url);
      if (!res.ok) throw new Error("Vectors HTTP " + res.status);

      const raw = await res.json();
      const text = raw?.result || "";
      return parseHorizonsCsvVectors(text);
    }

    function clearTrack(){
      if (trackLine){
        scene.remove(trackLine);
        trackLine.geometry.dispose();
        trackLine.material.dispose();
        trackLine = null;
      }
    }

    function buildHorizonsTrack(obj, minutesAhead = 360, stepMin = 5){
      if (!obj?.rows?.length) return;

      const pts = [];
      const now = new Date();
      const jd0 = toJulianForHorizons(now);

      for (let m = 0; m <= minutesAhead; m += stepMin){
        const jd = jd0 + (m / 1440);
        const st = sampleVectorsAt(obj.rows, jd);
        if (!st) continue;

        const x = st.x_km * currentScale;
        const y = st.z_km * currentScale;
        const z = -st.y_km * currentScale;

        pts.push(new THREE.Vector3(x, y, z));
      }

      if (pts.length < 2) return;

      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color: 0xFFCC33, transparent:true, opacity:0.85 });
      trackLine = new THREE.Line(geo, mat);
      trackLine.userData.last = performance.now();
      scene.add(trackLine);
    }

    // tiny concurrency limiter for Horizons loads
    async function mapLimit(arr, limit, fn){
      const results = new Array(arr.length);
      let idx = 0;

      async function worker(){
        while (idx < arr.length){
          const i = idx++;
          try { results[i] = await fn(arr[i], i); }
          catch (e) { results[i] = { __error: e }; }
        }
      }

      const workers = [];
      for (let k=0; k<Math.max(1, limit); k++) workers.push(worker());
      await Promise.all(workers);
      return results;
    }

    async function loadBodyHorizons(body){
      if (horizonsLoadPromise) return horizonsLoadPromise;

      horizonsLoadPromise = (async () => {
        const center = BODY_CENTER[body];
        const craftList = BODY_CRAFT[body] || [];

        clearAll();
        setSelectedName("—");
        selected = null;
        clearTrack();

        if (!center || !craftList.length){
          catalogNoteEl.textContent = "Catalog: " + body + " (not wired)";
          setStatus("READY");
          launchOut.value =
            "Selected body: " + body +
            "\n\nNo Horizons spacecraft list configured for this body.\n";
          return;
        }

        setStatus("LOADING CATALOG…");
        catalogNoteEl.textContent = "Catalog: " + body + " / Horizons (loading…)";

        const start = nowIsoUTC();
        const stop  = addHoursIsoUTC(12); // 12h ahead
        const stepMin = 2;                // 2-minute samples

        // Lookup SPKIDs (prefer provided spkid)
        const lookedUp = await mapLimit(craftList, 4, async (c) => {
          if (c?.spkid) return { displayName: (c.name || c.query || String(c.spkid)), spkid: String(c.spkid) };
          const r = await horizonsLookupBest(c.query || c.name);
          if (!r?.spkid) return null;
          return { displayName: (c.name || r.name || c.query), spkid: String(r.spkid) };
        });

        const resolved = lookedUp.filter(Boolean);

        // Fetch vectors
        const craft = await mapLimit(resolved, 3, async (obj) => {
          const rows = await horizonsVectorsRows(obj.spkid, center, start, stop, stepMin);
          if (!rows || rows.length < 2) return null;
          return { name: obj.displayName, norad: obj.spkid, rows, meshIndex: -1 };
        });

        sats = craft.filter(Boolean);

        buildSatInstancedMesh(sats.length);
        updateSatCount(sats.length);
        catalogNoteEl.textContent = `Catalog: ${body} / Horizons (${sats.length} objects)`;
        setStatus("READY");
        renderSatList();

        if (!sats.length){
          launchOut.value =
            `Selected body: ${body}\n\n` +
            "Horizons returned 0 usable objects from the current list.\n" +
            "This usually means the lookup names didn’t resolve.\n" +
            "Fix by switching entries to explicit {spkid:\"...\"} once confirmed.\n";
        }
      })();

      horizonsLoadPromise.finally(() => { horizonsLoadPromise = null; });
      return horizonsLoadPromise;
    }

    // ---------- TLE parsing ----------
    function parseTleText(text){
      const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      const out = [];
      for (let i=0;i<lines.length-2;i++){
        const name = lines[i];
        const l1 = lines[i+1];
        const l2 = lines[i+2];
        if (l1.startsWith("1 ") && l2.startsWith("2 ")){
          const norad = l1.slice(2,7).trim();
          out.push({ name, norad, l1, l2 });
          i += 2;
        }
      }
      return out;
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    function buildSatInstancedMesh(n){
      if (satMesh){
        scene.remove(satMesh);
        satMesh.geometry.dispose();
        satMesh.material.dispose();
      }
      const geom = new THREE.SphereGeometry(SAT_POINT_RADIUS, 10, 10);
      const mat  = new THREE.MeshBasicMaterial({ color: 0xffffff });
      satMesh = new THREE.InstancedMesh(geom, mat, Math.max(1, n));
      satMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      satMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(Math.max(1, n)*3), 3);
      satMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);

      const m = new THREE.Matrix4();
      for (let i=0;i<n;i++){
        m.makeTranslation(99999,99999,99999);
        satMesh.setMatrixAt(i, m);
        satMesh.setColorAt(i, SAT_COLOR_DEFAULT);
        sats[i].meshIndex = i;
      }
      satMesh.instanceMatrix.needsUpdate = true;
      satMesh.instanceColor.needsUpdate = true;

      scene.add(satMesh);
    }

    function renderSatList(){
      const q = (searchEl.value || "").trim().toLowerCase();
      const matches = [];
      for (const s of sats){
        if (!q || s.name.toLowerCase().includes(q) || String(s.norad).includes(q)) matches.push(s);
        if (matches.length >= 80) break;
      }
      satListEl.innerHTML = "";
      for (const s of matches){
        const row = document.createElement("div");
        row.className = "satItem";
        row.innerHTML = `<div class="satName">${escapeHtml(s.name)} <span style="color:rgba(159,179,217,.8);font-weight:700">(${escapeHtml(String(s.norad))})</span></div><div class="pill">TRACK</div>`;
        row.addEventListener("click", () => selectSatByNorad(String(s.norad)));
        satListEl.appendChild(row);
      }
    }

    function setAllColorsDefault(){
      if (!satMesh) return;
      for (let i=0;i<sats.length;i++) satMesh.setColorAt(i, SAT_COLOR_DEFAULT);
      satMesh.instanceColor.needsUpdate = true;
    }

    function selectSatByNorad(norad){
      const s = sats.find(x => String(x.norad) === String(norad)) || null;
      selected = s;
      setSelectedName(s ? s.name : "—");

      if (satMesh){
        setAllColorsDefault();
        if (s){
          satMesh.setColorAt(s.meshIndex, SAT_COLOR_SELECTED);
          satMesh.instanceColor.needsUpdate = true;
        }
      }

      clearTrack();

      // Earth TLE track
      if (s && s.satrec && satellite) {
        buildSelectedTrack(s, 90, 2);
      }
      // Horizons track (Moon/Mars/Jupiter)
      else if (s && s.rows) {
        buildHorizonsTrack(s, 360, 5);
      }
    }

    function buildSelectedTrack(sat, minutesAhead=90, stepMin=2){
      const pts = [];
      const now = new Date();
      for (let m=0; m<=minutesAhead; m+=stepMin){
        const t = new Date(now.getTime() + m*60*1000);
        const pv = satellite.propagate(sat.satrec, t);
        if (!pv.position) continue;
        const gmst = satellite.gstime(t);
        const ecef = satellite.eciToEcf(pv.position, gmst);
        pts.push(ecefKmToScene(ecef));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color: 0xFFCC33, transparent:true, opacity:0.85 });
      trackLine = new THREE.Line(geo, mat);
      trackLine.userData.last = performance.now();
      scene.add(trackLine);
    }

    function updateSatPositions(){
      if (!satMesh || !sats.length) return;

      // Earth TLE path
      if (satellite && sats[0]?.satrec){
        const t = new Date();
        const gmst = satellite.gstime(t);

        const mat4 = new THREE.Matrix4();
        for (let i=0;i<sats.length;i++){
          const s = sats[i];
          const pv = satellite.propagate(s.satrec, t);
          if (!pv.position){
            mat4.makeTranslation(99999,99999,99999);
            satMesh.setMatrixAt(i, mat4);
            continue;
          }
          const ecef = satellite.eciToEcf(pv.position, gmst);
          const p = ecefKmToScene(ecef);
          mat4.makeTranslation(p.x, p.y, p.z);
          satMesh.setMatrixAt(i, mat4);
        }
        satMesh.instanceMatrix.needsUpdate = true;

        if (selected){
          const pv = satellite.propagate(selected.satrec, t);
          if (pv.position && pv.velocity){
            const geo = satellite.eciToGeodetic(pv.position, gmst);
            infoLat.textContent = satellite.degreesLat(geo.latitude).toFixed(2);
            infoLon.textContent = satellite.degreesLong(geo.longitude).toFixed(2);
            infoAlt.textContent = geo.height.toFixed(1);
            const v = pv.velocity;
            const spd = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
            infoSpd.textContent = spd.toFixed(3);
            infoUtc.textContent = t.toISOString().replace("T"," ").slice(0,19) + "Z";
          }
        } else {
          infoLat.textContent = infoLon.textContent = infoAlt.textContent = infoSpd.textContent = infoUtc.textContent = "—";
        }
        return;
      }

      // Horizons path
      const jdNow = toJulianForHorizons(new Date());
      const mat4 = new THREE.Matrix4();

      for (let i=0;i<sats.length;i++){
        const s = sats[i];
        const st = sampleVectorsAt(s.rows, jdNow);
        if (!st){
          mat4.makeTranslation(99999,99999,99999);
          satMesh.setMatrixAt(i, mat4);
          continue;
        }

        const x = st.x_km * currentScale;
        const y = st.z_km * currentScale;
        const z = -st.y_km * currentScale;

        mat4.makeTranslation(x, y, z);
        satMesh.setMatrixAt(i, mat4);
      }

      satMesh.instanceMatrix.needsUpdate = true;

      if (selected){
        const st = sampleVectorsAt(selected.rows, jdNow);
        if (st){
          const r = Math.sqrt(st.x_km*st.x_km + st.y_km*st.y_km + st.z_km*st.z_km);
          const lat = Math.asin(st.z_km / r) * 180/Math.PI;
          const lon = Math.atan2(st.y_km, st.x_km) * 180/Math.PI;
          const bodyR = BODY_RADIUS_KM[currentBody] || EARTH_KM;
          const alt = r - bodyR;

          const spd = Math.sqrt(st.vx_kms*st.vx_kms + st.vy_kms*st.vy_kms + st.vz_kms*st.vz_kms);

          infoLat.textContent = lat.toFixed(2);
          infoLon.textContent = lon.toFixed(2);
          infoAlt.textContent = alt.toFixed(1);
          infoSpd.textContent = spd.toFixed(3);
          infoUtc.textContent = new Date().toISOString().replace("T"," ").slice(0,19) + "Z";
        }
      } else {
        infoLat.textContent = infoLon.textContent = infoAlt.textContent = infoSpd.textContent = infoUtc.textContent = "—";
      }
    }

    async function loadEarthActive(){
      if (earthLoadPromise) return earthLoadPromise;

      earthLoadPromise = (async () => {
        if (!satellite){
          setStatus("SAT DISABLED");
          alert("satellite.js is not loaded, so satellites are disabled.");
          return;
        }

        setStatus("LOADING CATALOG…");
        setSelectedName("—");
        selected = null;
        clearTrack();

        const url = "https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=tle";

        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), 20000);

        let res;
        try {
          res = await fetch(url, { cache: "no-store", signal: ctrl.signal });
        } finally {
          clearTimeout(timer);
        }

        if (!res.ok) throw new Error("Catalog HTTP " + res.status);

        const text = await res.text();
        const items = parseTleText(text);

        sats = items.map(it => {
          const sr = satellite.twoline2satrec(it.l1, it.l2);
          const inclDeg = sr.inclo * 180 / Math.PI;
          return { name: it.name, norad: it.norad, satrec: sr, inclDeg, meshIndex: -1 };
        });

        buildSatInstancedMesh(sats.length);
        updateSatCount(sats.length);
        catalogNoteEl.textContent = "Catalog: Earth / active (" + sats.length + " objects)";
        setStatus("READY");
        renderSatList();
      })();

      earthLoadPromise.finally(() => { earthLoadPromise = null; });
      return earthLoadPromise;
    }

    function clearAll(){
      setStatus("READY");
      sats = [];
      selected = null;
      updateSatCount(0);
      setSelectedName("—");
      catalogNoteEl.textContent = "Catalog: —";
      satListEl.innerHTML = "";
      clearTrack();
      if (satMesh){
        scene.remove(satMesh);
        satMesh.geometry.dispose();
        satMesh.material.dispose();
        satMesh = null;
      }
    }

    function onBodyChange(){
      const body = bodySelectEl.value;

      currentBody = body;
      currentScale = R / (BODY_RADIUS_KM[currentBody] || EARTH_KM);

      switchBodyMaterial(body);

      if (body === "earth"){
        catalogNoteEl.textContent = "Catalog: Earth / active (loading…)";
        setStatus("LOADING…");

        loadEarthActive().catch(e => {
          setStatus("ERROR");
          alert(String(e));
        });

        return;
      }

      loadBodyHorizons(body).catch(e => {
        setStatus("ERROR");
        console.error(e);
        alert(String(e));
      });
    }

    function computeLaunchOverview(){
      // ---- helpers ----
      const rad = (d) => d * Math.PI / 180;
      const deg = (r) => r * 180 / Math.PI;
      const clamp = (x, a, b) => Math.min(b, Math.max(a, x));

      function parseLatLon(text){
        const parts = String(text).split(",").map(s => s.trim());
        if (parts.length !== 2) throw new Error("Launch site must be 'lat,lon'");
        const lat = Number(parts[0]);
        const lon = Number(parts[1]);
        if (!isFinite(lat) || !isFinite(lon)) throw new Error("Launch site lat/lon must be numbers");
        if (lat < -90 || lat > 90) throw new Error("Latitude must be between -90 and 90");
        if (lon < -180 || lon > 180) throw new Error("Longitude must be between -180 and 180");
        return { lat, lon };
      }

      // Julian day
      function toJulian(date){
        return date.getTime()/86400000 + 2440587.5;
      }

      // Approx solar elevation (deg) at given lat/lon/time
      function solarElevationDeg(date, latDeg, lonDeg){
        const jd = toJulian(date);
        const n = jd - 2451545.0;

        const L = (280.460 + 0.9856474 * n) % 360;
        const g = rad((357.528 + 0.9856003 * n) % 360);

        const lambda = rad((L + 1.915*Math.sin(g) + 0.020*Math.sin(2*g)) % 360);

        const eps = rad(23.439 - 0.0000004 * n);

        const sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
        const sinEps = Math.sin(eps), cosEps = Math.cos(eps);

        const alpha = Math.atan2(cosEps*sinLambda, cosLambda);
        const delta = Math.asin(sinEps*sinLambda);

        const T = (jd - 2451545.0)/36525.0;
        let GMST = 280.46061837 + 360.98564736629*(jd - 2451545.0) + 0.000387933*T*T - (T*T*T)/38710000.0;
        GMST = ((GMST % 360) + 360) % 360;

        const LST = rad(((GMST + lonDeg) % 360 + 360) % 360);
        const H = LST - alpha;

        const lat = rad(latDeg);
        const sinEl = Math.sin(lat)*Math.sin(delta) + Math.cos(lat)*Math.cos(delta)*Math.cos(H);
        return deg(Math.asin(clamp(sinEl, -1, 1)));
      }

      function classifyLight(elDeg){
        if (elDeg > 0) return "DAY";
        if (elDeg > -6) return "CIVIL TWILIGHT";
        if (elDeg > -12) return "NAUTICAL TWILIGHT";
        if (elDeg > -18) return "ASTRO TWILIGHT";
        return "NIGHT";
      }

      // ---- inputs ----
      let site, incDeg, altKm;
      try {
        site = parseLatLon(launchLatLon.value);
        incDeg = Number(targetIncEl.value);
        altKm = Number(targetAltEl.value);
        if (!isFinite(incDeg) || incDeg <= 0 || incDeg >= 180) throw new Error("Inclination must be between 0 and 180 deg");
        if (!isFinite(altKm) || altKm < 120 || altKm > 50000) throw new Error("Altitude must be a reasonable value in km (e.g., 120–50000)");
      } catch (e){
        launchOut.value = "INPUT ERROR:\n" + String(e.message || e);
        return;
      }

      const latAbs = Math.abs(site.lat);

      let reachable = incDeg >= latAbs && incDeg <= (180 - latAbs);
      let azPrograde = null;
      let azRetrograde = null;

      if (reachable){
        const phi = rad(site.lat);
        const i = rad(incDeg);
        const ratio = clamp(Math.cos(i)/Math.cos(phi), -1, 1);
        const Az = Math.asin(ratio);
        azPrograde = (deg(Az) + 360) % 360;
        azRetrograde = (180 - azPrograde + 360) % 360;
      }

      const MU = 398600.4418;
      const r = EARTH_KM + altKm;
      const vOrb = Math.sqrt(MU / r);
      const vRotEq = 0.465101;
      const vRot = vRotEq * Math.cos(rad(site.lat));

      let assistPro = null, assistRetro = null;
      if (reachable){
        const eastComponentPro = Math.sin(rad(azPrograde));
        assistPro = vRot * eastComponentPro;
        const eastComponentRetro = Math.sin(rad(azRetrograde));
        assistRetro = vRot * eastComponentRetro;
      }

      let congestionText = "Congestion: (sat catalog not loaded)";
      if (satellite && sats && sats.length && sats[0]?.satrec){
        const now = new Date();
        const gmst = satellite.gstime(now);
        const incTol = 2.0;
        const altTol = 50.0;

        let inBand = 0;
        for (const s of sats){
          if (Math.abs((s.inclDeg ?? 0) - incDeg) > incTol) continue;
          const pv = satellite.propagate(s.satrec, now);
          if (!pv.position) continue;
          const geo = satellite.eciToGeodetic(pv.position, gmst);
          const h = geo.height;
          if (Math.abs(h - altKm) <= altTol) inBand++;
        }

        const pct = (inBand / sats.length) * 100;
        congestionText = `Congestion: ${inBand} sats within ±${incTol}° incl and ±${altTol} km alt (${pct.toFixed(2)}% of loaded catalog)`;
      }

      const start = new Date();
      const stepMin = 30;
      const steps = Math.floor((24 * 60) / stepMin);

      let lines = [];
      lines.push("LAUNCH WINDOW OVERVIEW (UTC)");
      lines.push("------------------------------------------------------------");
      lines.push(`Site: lat ${site.lat.toFixed(4)}, lon ${site.lon.toFixed(4)}`);
      lines.push(`Target: inc ${incDeg.toFixed(2)}°, alt ${altKm.toFixed(0)} km`);
      lines.push("");

      if (!reachable){
        lines.push("REACHABILITY: ❌ NOT DIRECTLY REACHABLE from this latitude");
        lines.push(`Rule of thumb: inclination must be ≥ |latitude|. Here |lat|=${latAbs.toFixed(2)}°`);
        lines.push("You would need a dogleg, plane change, or a different site.");
      } else {
        lines.push("REACHABILITY: ✅ DIRECTLY REACHABLE");
        lines.push(`Suggested azimuths (from North → East):`);
        lines.push(`  Prograde:   ${azPrograde.toFixed(1)}°   (rotation assist ~ ${assistPro.toFixed(3)} km/s)`);
        lines.push(`  Retrograde: ${azRetrograde.toFixed(1)}°   (rotation assist ~ ${assistRetro.toFixed(3)} km/s)`);
      }

      lines.push("");
      lines.push(`Orbital speed @ ${altKm.toFixed(0)} km (circular): ~${vOrb.toFixed(3)} km/s`);
      lines.push(congestionText);
      lines.push("");

      lines.push("NEXT 24 HOURS (lighting at site):");
      lines.push("Time (UTC)            SunEl   Condition            Go/Note");
      lines.push("------------------------------------------------------------");

      for (let k=0; k<=steps; k++){
        const t = new Date(start.getTime() + k*stepMin*60*1000);
        const elv = solarElevationDeg(t, site.lat, site.lon);
        const cond = classifyLight(elv);

        let go = "NO";
        let note = "";
        if (reachable){
          if (cond === "NIGHT" || cond.includes("TWILIGHT")) { go = "GO"; note = "better visuals/ops"; }
          else { go = "CAUTION"; note = "daylight"; }
        } else {
          note = "inclination not reachable";
        }

        const ts = t.toISOString().replace("T"," ").slice(0,16) + "Z";
        lines.push(`${ts}   ${elv.toFixed(1).padStart(5)}°  ${cond.padEnd(18)}  ${go} ${note}`);
      }

      launchOut.value = lines.join("\n");
    }

    // Wire UI
    el("clearBtn").addEventListener("click", clearAll);
    el("launchBtn").addEventListener("click", computeLaunchOverview);

    el("downloadLaunchBtn").addEventListener("click", () => {
      const txt = (launchOut.value || "").trim();
      if (!txt){
        alert("No launch overview yet. Click Compute Launch Window Overview first.");
        return;
      }
      const stamp = new Date().toISOString().replace(/[:.]/g,"-");
      downloadText(`launch-overview-${stamp}.txt`, txt + "\n");
    });

    searchEl.addEventListener("input", renderSatList);
    bodySelectEl.addEventListener("change", onBodyChange);

    // Load initial body
    if (!planetMesh) buildFallbackEarth();
    switchBodyMaterial(bodySelectEl.value);
    onBodyChange();

    // Animate loop
    function animate(){
      const nowMs = performance.now();
      if (nowMs - lastPosUpdateMs > 1000){
        updateSatPositions();
        lastPosUpdateMs = nowMs;

        // Refresh Earth track
        if (satellite && selected && trackLine && selected?.satrec && (nowMs - (trackLine.userData.last || 0) > 10000)){
          clearTrack();
          buildSelectedTrack(selected, 90, 2);
        }

        // Refresh Horizons track
        if (selected && selected?.rows && trackLine && !selected?.satrec && (nowMs - (trackLine.userData.last || 0) > 10000)){
          clearTrack();
          buildHorizonsTrack(selected, 360, 5);
        }
      }
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    setStatus("READY");
  })();
</script>
</body>
</html>
